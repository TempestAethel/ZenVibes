<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Throwable Ball (Stress Relief)</title>
    <style>
        /* Basic resets */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #1c1c1c; /* Dark theme background */
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Toggle button styling */
        .toggle-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #008080;
            color: white;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease-in-out;
        }

        .toggle-btn:hover {
            background-color: #00b3b3;
        }

        .toggle-btn:focus {
            outline: none;
        }

        /* Canvas Styling */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>

<canvas id="canv"></canvas>
<button class="toggle-btn" id="toggleBoundaries">Disable Boundaries</button>

<script>
    // Point class for position and mouse position
    function Pt(x, y) {
        this.x = x;
        this.y = y;
    }

    // Dot class for random dots
    function Dot() {
        this.pos = new Pt(Math.random() * c.width, Math.random() * c.height);  // Random position
        this.radius = Math.random() * 10 + 5;  // Random radius between 5 and 15
    }

    // Ball class
    function Ball() {
        this.pos = new Pt(c.width / 2, c.height / 2);  // Ball position
        this.mPos = new Pt(0, 0);  // Mouse position
        this.Xvel = 0;  // X velocity
        this.Yvel = 0;  // Y velocity
        this.accel = new Pt(0, 0);  // Acceleration
        this.boundaryEnabled = true;  // Boundary flag
    }

    // Drawing the ball
    Ball.prototype.draw = function () {
        $.fillStyle = "hsla(180, 100%, 50%, 1)";  // Neon cyan color
        $.shadowColor = 'hsla(180, 100%, 50%, 0.8)';  // Neon glow effect
        $.shadowBlur = 20;
        $.shadowOffsetX = 5;
        $.shadowOffsetY = 5;
        $.beginPath();
        $.arc(this.pos.x, this.pos.y, 60, 0, 2 * Math.PI); // Draw the circle (ball)
        $.fill();
    };

    // Updating the ball's position
    Ball.prototype.update = function () {
        this.accel.x = (this.mPos.x - this.pos.x) * 0.01; // Spring-like effect
        this.accel.y = (this.mPos.y - this.pos.y) * 0.01;

        this.Xvel += this.accel.x;
        this.Yvel += this.accel.y;

        // Update the ball's position
        this.pos.x += this.Xvel;
        this.pos.y += this.Yvel;

        // Apply damping
        this.Xvel *= 0.97;
        this.Yvel *= 0.97;

        // Constrain ball within the window boundaries (if enabled)
        if (this.boundaryEnabled) {
            const ballRadius = 60;  // Radius of the ball
            if (this.pos.x < ballRadius) {
                this.pos.x = ballRadius;
                this.Xvel *= -0.5; // Reflect the velocity
            } else if (this.pos.x > c.width - ballRadius) {
                this.pos.x = c.width - ballRadius;
                this.Xvel *= -0.5; // Reflect the velocity
            }

            if (this.pos.y < ballRadius) {
                this.pos.y = ballRadius;
                this.Yvel *= -0.5; // Reflect the velocity
            } else if (this.pos.y > c.height - ballRadius) {
                this.pos.y = c.height - ballRadius;
                this.Yvel *= -0.5; // Reflect the velocity
            }
        }
    };

    // Update mouse position
    Ball.prototype.mouseMove = function (e) {
        this.mPos.x = e.clientX;
        this.mPos.y = e.clientY;
    };

    // Resize canvas on window resize
    function resizeCanv() {
        c.width = window.innerWidth;
        c.height = window.innerHeight;
        if (ball) ball.pos = new Pt(c.width / 2, c.height / 2);  // Reposition the ball
    }

    // Set up the canvas
    var c = document.getElementById('canv');
    var $ = c.getContext('2d');

    window.addEventListener('resize', resizeCanv, false);
    resizeCanv();  // Initial canvas size adjustment

    // Singleton Ball instance
    var ball = new Ball();

    // Array of random dots
    var dots = [];
    var numDots = 20; // Number of random dots to spawn

    // Function to spawn random dots
    function spawnDots() {
        for (var i = 0; i < numDots; i++) {
            dots.push(new Dot());
        }
    }

    // Call function to spawn initial dots
    spawnDots();

    // Function to check collision between ball and a dot
    function checkCollision(dot) {
        const dx = dot.pos.x - ball.pos.x;
        const dy = dot.pos.y - ball.pos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < 60 + dot.radius; // Ball's radius + dot's radius
    }

    // Remove dots that are hit by the ball
    function removeHitDots() {
        for (var i = 0; i < dots.length; i++) {
            if (checkCollision(dots[i])) {
                dots.splice(i, 1);  // Remove the dot from the array
                i--;  // Adjust index after removal
            }
        }
    }

    // Drawing the dots
    function drawDots() {
        $.fillStyle = "hsla(100, 100%, 50%, 1)";  // Green color for dots
        for (var i = 0; i < dots.length; i++) {
            $.beginPath();
            $.arc(dots[i].pos.x, dots[i].pos.y, dots[i].radius, 0, 2 * Math.PI);
            $.fill();
        }
    }

    // Function to periodically spawn new dots
    function periodicDotRespawn() {
        // After 2 seconds, spawn new dots
        setInterval(function () {
            // Spawn new dots only if the number of dots is below the limit
            if (dots.length < numDots) {
                dots.push(new Dot());
            }
        }, 2000); // Every 2 seconds
    }

    // Call function to periodically spawn dots
    periodicDotRespawn();

    // Handle mouse events to move the ball
    window.addEventListener('mousemove', function (e) {
        ball.mPos.x = e.clientX;
        ball.mPos.y = e.clientY;
    });

    // Toggle button functionality for enabling/disabling boundaries
    document.getElementById('toggleBoundaries').addEventListener('click', function () {
        ball.boundaryEnabled = !ball.boundaryEnabled;
        this.textContent = ball.boundaryEnabled ? "Disable Boundaries" : "Enable Boundaries";
    });

    // Request Animation Frame for smooth animation
    window.requestAnimFrame = (function (callback) {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
            function (callback) {
                window.setTimeout(callback, 1000 / 60);
            };
    })();

    // Animation loop
    function animate() {
        // Update ball position
        ball.update();

        // Clear the canvas
        $.clearRect(0, 0, c.width, c.height);

        // Draw the ball
        ball.draw();

        // Draw and check for collisions with dots
        drawDots();
        removeHitDots();

        // Request new animation frame
        window.requestAnimFrame(animate);
    }

    animate();

</script>

</body>
</html>
